/**
 * File:	modules/IUCVTerminalServer.ycp
 * Package:	Configuration IUCV Terminal Server
 * Summary:	IUCV Terminal Server settings, input and output functions
 * Authors:	Tim Hardeck <thardeck@suse.de>
 *
 */

{

module "IUCVTerminalServer";
textdomain "s390";

import "FileUtils";
import "Report";
import "String";
import "Progress";
import "Integer";
import "Popup";
import "Users";

/**
 * Text to select all
 */
global define const string TEXT_ALL = _("<ALL>");

/**
 * Path of the TS-Shell
 */
define const string TSSHELL_SHELL = "/usr/bin/ts-shell";

/**
 * Path of the IUCVConn shell
 */
define const string IUCVCONN_SHELL = "/usr/bin/iucvconn_on_login";

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * List of zvmids
 */
global list<string> zvm_id_list = [];

/**
 * Is TS-Shell enabled?
 */
global boolean ts_enabled = false;

/**
 * TS-Shell Home Directory
 */
global string ts_home = "/home/tsshell";

/**
 * List of audited tsshell ids
 */
global list<string> ts_audited_ids = [];

/**
 * Did the TS-Shell status change (from off to on or vice versa)
 */
global boolean ts_has_status_changed = false;

/**
 * List/Regex/file map per TS-Shell user/group
 * the key of the first map is the user/group name
 * the key of the second map is the selected radio button symbol
 */
global define map<string, map<symbol, any> > ts_member_conf = $[ ];

/**
 * Map of the loaded ts-authorization.conf settings (for saving purposes)
 */
define map<string, any> ts_authorization_map = $[ ];


/**
 * Is IUCVConn enabled?
 */
global boolean ic_enabled = false;

/**
 * IUCVConn Home Directory
 */
global string ic_home = "/home/iucvconn";

global boolean CheckUserGroupName (string name) {
	return regexpmatch(name, "^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_][ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-]*[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.$-]\?$");
}

/**
 * GetUsers
 * @param boolean local (only local users?)
 * @return map of users
 */
global map <string, map> GetUsers (boolean local) {
	map<string, map> users = (map<string, map>) Users::GetUsers ("uid","local");
	if (!local)
	{
		users = (map<string, map>) union (users, Users::GetUsers ("uid","system"));
	}
	return users;
}

/**
 * GetGroups
 * @param boolean local (only local groups?)
 * @return map of groups
 */
global map <string, map> GetGroups (boolean local) {
	map<string, map> groups = (map<string, map>) Users::GetGroups ("cn","local");
	if (!local)
	{
		groups = (map<string, map>) union (groups, Users::GetGroups ("cn","system"));
	}
	return groups;
}

/**
 * Delete users
 * @param username
 * @return boolean true if deletion was successful
 */
global boolean DeleteUser (string username)
{
	Users::SelectUserByName (username);
	// don't remove home since we only have one for all
	boolean ret = Users::DeleteUser (false);
	Users::CommitUser ();
	return ret;
}

/**
 * Gather all users which have TS-Shell as their shell
 * @return list of usernames
 */
global list<string> GetTsUsersList () {
	list<string> ts_users = [];
	map<string, map> local_users = GetUsers(true);
	foreach (string username, map user, local_users,{
		if ( user["loginShell"]:nil == TSSHELL_SHELL )
		{
			ts_users = add(ts_users, username);
		}
	});
	return ts_users;
}

/**
 * Gather all users which have TS-Shell as their shell
 * @return list of usernames
 */
global list<string> GetIcUsersList () {
	list<string> ic_users = [];
	map<string, map> local_users = GetUsers(true);
	foreach (string username, map user, local_users,{
		if ( user["loginShell"]:nil == IUCVCONN_SHELL )
		{
			ic_users = add(ic_users, username);
		}
	});
	return ic_users;
}

/**
 * Abstract add a new user function
 * @parm string username, string password, string group_id, string home, string shell,  map<string, string> additional_groups ($[user : "1", user2 : "1" ...]
 * @return the new user id as a string
 */
define string AddUser(string username, string password, string group_id, string home, string shell,  map<string, string> additional_groups, boolean force_pw_change) {
	string new_userid = "";

	// create home directory if it doesn't exist
	boolean create_home = !FileUtils::IsDirectory(home);

	// make sure that the user doesn't already exist
	map<string, map> users = GetUsers(false);

	if (!haskey(users, username))
	{
		map <string, any> user = $[
			"uid"				: username,
			"loginShell"		: shell,
			"homeDirectory"		: home,
			"userPassword"		: password,
			"create_home"		: create_home,
			"chown_home"		: false,
			"grouplist"			: additional_groups
		];
		// only change the default group id if defined
		if (group_id != "")
		{
			user = add(user, "gidNumber", group_id);
		}
		if (force_pw_change)
		{
			user = add(user, "shadowLastChange", "0");
		}

		string error = Users::AddUser (user);
		// if adding successfull
		if (error == "")
		{
			Users::CommitUser();

			// get uid of the new user
			map <string, any> user = Users::GetUserByName (username, "");
			new_userid = user["uidNumber"]:"0";
		}
		else
		{
			y2milestone("Adding user %1 failed with the error: %2", username, error);
		}
	}
	else
	{
		y2milestone("The user %1 does already exist.", username);
	}
	return new_userid;
}

/**
 * Sync z/VM ids with the user accounts
 * @parm list of z/VM ids and the default IC password
 * @return void
 */
global void SyncIucvConnUsers (list<string> zvmid_list, string ic_password) {
	y2milestone("Syncing IUCVConn users.");

	list<string> ic_users = GetIcUsersList();

	// delete obsolete users
	list<string> obsolete_users = filter (string user, ic_users, { return (!contains(zvmid_list, user)); });
	foreach (string  user, obsolete_users,{
		y2milestone("Delete obsolete IUCVConn user %1", user);
		DeleteUser(user);
	});

	// add missing users
	list<string> users_to_add = filter (string user, zvmid_list, { return (!contains(ic_users, user)); });
	foreach (string  user, users_to_add,{
		y2milestone("Add missing IUCVConn user %1", user);
		AddUser(user, ic_password, "", ic_home, IUCVCONN_SHELL,  $[], false);
	});
}

/**
 * Add a new TS-Shell user
 * @parm string username, string password, string home, map<string, string> additional_groups ($[user : "1", user2 : "1" ...]
 * @return the new user id as a string
 */
global string AddTsUser(string username, string password, string home, map<string, string> additional_groups, boolean force_pw_change) {
	y2milestone("Adding TS-Shell user %1.", username);
	// get TS-Shell group id
	map group = Users::GetGroupByName ("ts-shell","system");
	string group_id = group["gidNumber"]:"";

	string new_uid = AddUser(username, password, group_id, home, TSSHELL_SHELL,  additional_groups, force_pw_change);

	return new_uid;
}

/**
 * Update a configuration entry for TS-Shell users and configured groups
 * @param name of the entry (groups start with an "@"); value
 * @return void
 */
define void UpdateTsMemberConfig(string name, string value) {
	// if entry doesn't exist create it
	if (!haskey(ts_member_conf, name))
	{
		ts_member_conf = add(ts_member_conf, name,
		$[	`type       : (symbol)`rb_ts_list,
			`rb_ts_list : (list <string>) [ ],
			`rb_ts_regex: (string) "",
			`rb_ts_file : (string) ""
		]);
	}

	// update entries
	if (regexpmatch( value, "^list:"))
	{
		// remove leading "list:"
		value = substring(value, 5);

		list<string> loaded_ids = splitstring(value, ",");
		// filter unknown z/VM IDs
		loaded_ids = filter (string name, loaded_ids, { return (contains(zvm_id_list, name)); });

		ts_member_conf[name, `rb_ts_list] = loaded_ids;
		ts_member_conf[name, `type] = `rb_ts_list;
	}
	else if (regexpmatch( value, "^regex:"))
	{
		value = substring(value, 6);
		ts_member_conf[name, `rb_ts_regex] = value;
		ts_member_conf[name, `type] = `rb_ts_regex;
	}
	else if (regexpmatch( value, "^file:"))
	{
		value = substring(value, 5);
		ts_member_conf[name, `rb_ts_file] = value;
		ts_member_conf[name, `type] = `rb_ts_file;
	}
}

/**
 * Read all settings
 * @return true on success
 */
global define boolean Read () {
	string caption  = _("Loading IUCV Terminal Server Configuration");
	integer steps   = 2;

	Progress::New (caption, " ", steps, [
	/* Progress stage 1/2 */
	_("Read configuration files"),
	/* Progress stage 2/2 */
	_("Load user/group settings")
	], [
	/* Progress step 1/2 */
	_("Reading configuration files..."),
	/* Progress step 2/2 */
	_("Loading user/group settings..."),
	/* Progress finished */
	_("Finished")
	],
	""
	);

	Progress::NextStage();
	y2milestone("Reading user and group entries.");
	boolean old_progress = Progress::set(false);
	// read global user and group entries
	Users::Read();
	Progress::set(old_progress);

	// initialize tsshell user list
	list<string> ts_users = GetTsUsersList();
	foreach (string username, ts_users,{
		UpdateTsMemberConfig(username, "");
	});

	// Load settings
	Progress::NextStage();
	string filename = "/etc/sysconfig/iucv_terminal_server";
	if (FileUtils::Exists (filename))
	{
		y2milestone("Reading configuration from sysconfig %1.", filename);
		string zvm_ids	= (string) SCR::Read(.sysconfig.iucv_terminal_server.ZVM_IDS);
		if (zvm_ids != nil)
		{
			zvm_id_list = splitstring(zvm_ids, " ");
		}

		ts_enabled		= ("true" == (string)SCR::Read(.sysconfig.iucv_terminal_server.ENABLE_TSSHELL));
		string home		= (string) SCR::Read(.sysconfig.iucv_terminal_server.TSSHELL_HOME);
		// use default if not set
		if (home != nil)
		{
			ts_home = home;
		}

		ic_enabled	= ("true" == (string)SCR::Read(.sysconfig.iucv_terminal_server.ENABLE_IUCVCONN));
		home		= (string) SCR::Read(.sysconfig.iucv_terminal_server.IUCVCONN_HOME);
		// user default if not set
		if (home != nil)
		{
			ic_home = home;
		}
	}

	filename = "/etc/iucvterm/ts-audit-systems.conf";
	if (FileUtils::Exists (filename))
	{
		y2milestone("Reading configuration from %1.", filename);
		list<string> original_ts_audited_ids = splitstring((string)SCR::Read (.target.string, filename), "\n");
		if(contains(original_ts_audited_ids, "[*ALL*]"))
		{
			// add all if configured
			ts_audited_ids = (list<string>) merge( [TEXT_ALL], zvm_id_list);
		}
		else
		{
			// only add known ids
			ts_audited_ids = filter (string name, original_ts_audited_ids, { return (!contains(zvm_id_list, name)); });
		}
	}

	filename = "/etc/iucvterm/ts-authorization.conf";
	if (FileUtils::Exists (filename))
	{
		y2milestone("Reading configuration from %1.", filename);
		// the settings map is globally kept for saving purposes
		ts_authorization_map = (map <string, any>) SCR::Read(.etc.iucvterm-ts-authorization.all);
		list <map <string, any> > ts_auth_list = ts_authorization_map["value"]:[];
		foreach (map <string, any> entry, ts_auth_list,{
			string name		= entry["name"]:"";
			string value	= entry["value"]:"";
			if (CheckUserGroupName(name))
			{
				// user entry
				UpdateTsMemberConfig(name, value);
			}
			else if (regexpmatch( name, "^@"))
			{
				// group entry
				map<string, map> groups = GetGroups(true);
				// remove "@" from the name for the group check
				string groupname = substring(name,1);
				if (haskey(groups, groupname))
				{
					UpdateTsMemberConfig(name, value);
				}
				else
				{
					y2milestone("The in %1 mentioned group %2 isn't available on this system.", filename, groupname);
				}
			}
			else
			{
				y2milestone("Incompatible configuration entry %1 in file %2", name, filename);
			}
		});
	}
	list<string> test = [];

	Progress::NextStage();
	return true;
}

/**
 * Write all settings
 * @return true on success
 */
global define boolean Write () {
	// no need to write anything if unmodified
	if (!modified)
	{
		return true;
	}

	string caption  = _("Saving IUCV Terminal Server Configuration");
	integer steps   = 2;

	Progress::New (caption, " ", steps, [
	/* Progress stage 1/2 */
	_("Write configuration files"),
	/* Progress stage 2/2 */
	_("Update user settings")
	], [
	/* Progress step 1/2 */
	_("Writing configuration files..."),
    /* Progress step 2/2 */
	_("Updating user settings..."),
	/* Progress finished */
	_("Finished")
	],
	""
	);

	// save IUCVtty settings
	Progress::NextStage();

	y2milestone("Writing configuration to sysconfig.");
	// save z/VM IDs separated by spaces
	SCR::Write(.sysconfig.iucv_terminal_server.ZVM_IDS, mergestring(zvm_id_list, " "));
	SCR::Write(.sysconfig.iucv_terminal_server.ENABLE_IUCVCONN, tostring(ic_enabled));
	SCR::Write(.sysconfig.iucv_terminal_server.IUCVCONN_HOME, ic_home);
	SCR::Write(.sysconfig.iucv_terminal_server.ENABLE_TSSHELL, tostring(ts_enabled));
	SCR::Write(.sysconfig.iucv_terminal_server.TSSHELL_HOME, ts_home);
	SCR::Write(.sysconfig.iucv_terminal_server, nil);


	string filename = "/etc/iucvterm/ts-audit-systems.conf";
	y2milestone("Writing configuration to %1.", filename);
	if (ts_audited_ids[0]:nil == TEXT_ALL)
	{
		SCR::Write (.target.string, filename, "[*ALL*]");
	}
	else
	{
		// save audited IDs separated by breaks
		SCR::Write (.target.string, filename, mergestring(ts_audited_ids, "\n"));
	}


	filename = "/etc/iucvterm/ts-authorization.conf";
	y2milestone("Writing configuration to %1.", filename);
	// convert the autorization settings to the output format
	map <string, string> ts_auth_values = $[];
	foreach(string name, map <symbol, any> entries, ts_member_conf, {
		string value = "";
		symbol type = (symbol) entries[`type]:nil;
		// Manual selection
		if(type == `rb_ts_list)
		{
			list<string> selected_ids = (list<string>)entries[type]:[];
			// remove the TEXT_ALL entry because it is not supported by the configuration
			if (selected_ids[0]:"" == TEXT_ALL)
			{
				selected_ids = remove(selected_ids, 0);
			}
			value = "list:" + mergestring(selected_ids, ",");
		}
		// Regex
		else if(type == `rb_ts_regex)
		{
			value = "regex:" + entries[type]:"";
		}
		// File
		else if(type == `rb_ts_file)
		{
			value = "file:" + entries[type]:"";
		}

		// ignore empty entries(like "list:" or "regex:")
		if (!regexpmatch(value, "^[[:lower:]]{4,5}:$"))
		{
			ts_auth_values = add(ts_auth_values, name, value);
		}
	});

	// update the original configuration file map with the new values
	list <map <string, any> > ts_auth_list = ts_authorization_map["value"]:[];
	integer counter = 0;
	foreach (map <string, any> entry, ts_auth_list,{
		string name = entry["name"]:"";
		// update the configuration entry if known otherwise delete it
		if (haskey(ts_auth_values, name) )
		{
			entry["value"] =  ts_auth_values[name]:nil;
			ts_auth_list[counter] = entry;
			counter = counter + 1;

			// remove already added ts_auth_values
			ts_auth_values = remove(ts_auth_values, name);
		}
		else
		{
			ts_auth_list = remove(ts_auth_list, counter);
		}
	});

	// add missing entries
	foreach (string name, string value, ts_auth_values,{
		map <string, any> new_map = $[
		"kind": "value",
		"name": name,
		"type": 0,                        /* value_type */
		"comment": "",
		"value": value
		];
		ts_auth_list = add(ts_auth_list, new_map);
	});

	// update list of the originally loaded map
	ts_authorization_map["value"] = ts_auth_list;

	// write the updated settings map to file
	SCR::Write(.etc.iucvterm-ts-authorization.all, ts_authorization_map);
	SCR::Write(.etc.iucvterm-ts-authorization, nil);


	Progress::NextStage();
	if (Users::Modified ())
	{
		y2milestone("Saving users and groups.");
		// disable Users progress bar
		boolean old_progress = Progress::set(false);
		string		error = Users::Write();
		Progress::set(old_progress);
		if (error != "")
		{
			y2milestone("Writing user settings failed because of: %1", error);
			Popup::Notify(error);
		}
	}

	// dis/enable TS-Users if the TS status had changed
	if (ts_has_status_changed)
	{
		y2milestone("Dis/enabling TS-Shell users.");
		string passwd = ts_enabled
		? "/usr/bin/passwd -u "		// unlock user
		: "/usr/bin/passwd -l ";	// lock user
		foreach(string name, map entries, ts_member_conf, {
			// groups don't need to be disabled
			if (!regexpmatch(name, "^@"))
			{
				string cmd = passwd + name;
				y2milestone ("Running command %1", cmd);
				map output = (map) SCR::Execute (.target.bash_output, cmd);
				y2milestone ("Passwd exit code: %1 stdout: %2 stderr: %3", output["exit"]:0, output["stdout"]:"", output["stderr"]:"");
			}
		});
	}

	Progress::NextStage();
	return true;
}
/* EOF */
}

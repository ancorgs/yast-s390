/**
 * File:	modules/DASDController.ycp
 * Package:	Configuration of controller
 * Summary:	Controller settings, input and output functions
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of controller.
 * Input and output routines.
 */
{
module "DASDController";
textdomain "s390";

import "Mode";
import "Report";
import "FileUtils";
import "Popup";
    import "String";


global map<integer,map<string,any> > devices = $[];

    global string filter_min = "0.0.0000";
    global string filter_max = "0.0.ffff";

global map<string, boolean> diag = $[];


global void ActivateDisk (string channel, boolean diag);
global void DeactivateDisk (string channel, boolean diag);
global void ProbeDisks ();
global void FormatDisks(list<string> disks_list, integer par, boolean write_vl);
global string GetPartitionInfo (string disk);
global boolean GetModified();


/**
 * Have DASDs been configured so that mkinitrd and zipl need to be run?
 */
boolean disk_configured = false;


/**
 * Data was modified?
 */
boolean modified = false;


/**
 */
global boolean proposal_valid = false;


/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = GetModified;


/**
 * Abort function
 * @return blah blah lahjk
 */
global boolean Abort()
{
    if(AbortFunction != nil)
	return AbortFunction ();
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean GetModified()
{
    return modified;
}


global void SetModified(boolean value)
{
    modified = value;
}


/**
 * Is this kind of disk controller available?
 * @return boolean true if it is
 */
global boolean Available()
{
    return true;
}


    string GetDeviceName(string channel)
    {
	string dir = sformat("/sys/bus/ccw/devices/%1/block/", channel);
	list<string> files = (list<string>) SCR::Read(.target.dir, dir);
	if (size(files) == 1)
	    return "/dev/" + files[0]:"";
	return nil;
    }


    global boolean IsValidChannel(string channel)
    {
	string regexp = "^([0-9a-fA-F]{1}).([0-9a-fA-F]{1}).([0-9a-fA-F]{1,4})$";
	return regexpmatch(channel, regexp);
    }
 
    global string FormatChannel(string channel)
    {
	if (!IsValidChannel(channel))
	    return channel;

	list<string> strs = splitstring(channel, ".");
	strs[2] = String::PadZeros(strs[2]:"", 4);
	return mergestring(strs, ".");
    }


/**
 * Read all controller settings
 * @return true on success
 */
global boolean Read()
{
    ProbeDisks();

    if (!Mode::normal())
    {
	devices = filter(integer index, map<string, any> d, devices, {
		return d["resource", "io", 0, "active"]:false;
	    });

	devices = mapmap(integer index, map<string, any> d, devices, {
		d["format"] = d["format"]:false;
		d["diag"] = d["diag"]:false;
		return $[ index : d ];
	    });
    }

    disk_configured = false;
    return true;
}


/**
 * Write all controller settings
 * @return true on success
 */
global boolean Write()
{
    if (!Mode::normal())
    {
	list<string> to_format = [];

	foreach(integer index, map<string, any> device, devices, {
		string channel = device["channel"]:"";
		boolean format = device["format"]:false;
		boolean do_diag = device["diag"]:false;
		ActivateDisk(channel, do_diag);

		if (format)
		{
		    string dev_name = GetDeviceName(channel);
		    if (dev_name != nil)
			to_format = add(to_format, dev_name);
		}
	    });

	y2milestone ("Disks to format: %1", to_format);

	if (!isempty(to_format))
	    FormatDisks(to_format, 8, true);
    }

    if (!Mode::installation())
    {
	if (disk_configured)
	{
	    // popup label
	    UI::OpenDialog(`Label(_("Running mkinitrd and zipl.")));

	    string command = "/sbin/mkinitrd && /sbin/zipl";
	    y2milestone("Running command %1", command);
	    any ret = SCR::Execute(.target.bash, command);
	    y2milestone("Exit code: %1", ret);

	    UI::CloseDialog();
	}
    }

    return true;
}


/**
 * Get all controller settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import(map settings)
{
	integer index = -1;
	devices = listmap (map<string, any> d, settings["devices"]:[], {
	    index = index + 1;

	    d["channel"] = FormatChannel(d["channel"]:"");

	    d = filter(string k, any v, d, {
		return contains([ "channel", "format", "diag" ], k);
	    });

	    return $[ index : d ];
	});

    return true;
}


/**
 * Dump the controller settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map<string, list> Export()
{
	list<map<string, any> > l = maplist(integer i, map<string, any> d, devices, {
	    return filter(string k, any v, d, {
		return contains([ "channel", "format", "diag" ], k);
	    });
	});

	return $[ "devices" : l ];
}


    global map<integer, map<string, any> >
    GetDevices()
    {
	return devices;
    }


    global map<integer, map<string, any> >
    GetFilteredDevices()
    {
	list<string> min_strs = splitstring(filter_min, ".");
	integer min_css = tointeger("0x" + min_strs[0]:"");
	integer min_lcss = tointeger("0x" + min_strs[1]:"");
	integer min_chan = tointeger("0x" + min_strs[2]:"");

	list<string> max_strs = splitstring(filter_max, ".");
	integer max_css = tointeger("0x" + max_strs[0]:"");
	integer max_lcss = tointeger("0x" + max_strs[1]:"");
	integer max_chan = tointeger("0x" + max_strs[2]:"");

	map<integer, map<string, any> > ret = GetDevices();

	if (min_chan > 0 || min_lcss > 0 || min_css > 0 ||
	    max_chan < 0xffff || max_lcss < 0xf || max_css < 0xf)
	{
	    y2milestone("filter devices: %1.%2.%3 to %4.%5.%6", min_css, min_lcss, min_chan,
			max_css, max_lcss, max_chan);

	    ret = filter(integer k, map<string, any> d, ret, {
		list<string> tmp_strs = splitstring(d["channel"]:"", ".");
		integer tmp_css = tointeger("0x" + tmp_strs[0]:"");
		integer tmp_lcss = tointeger("0x" + tmp_strs[1]:"");
		integer tmp_chan = tointeger("0x" + tmp_strs[2]:"");

		return tmp_css >= min_css && tmp_lcss >= min_lcss && tmp_chan >= min_chan &&
		    tmp_css <= max_css && tmp_lcss <= max_lcss && tmp_chan <= max_chan;
	    });
	}

	return ret;
    }


    global void
    AddDevice(map<string, any> d)
    {
	integer index = 0;
	while (haskey(devices, index))
	    index = index + 1;
	devices[index] = d;
    }


    global void
    RemoveDevice(integer index)
    {
	devices = remove(devices, index);
    }


    global integer
    GetDeviceIndex(string channel)
    {
	integer ret = nil;
	foreach(integer index , map<string, any> d, devices, {
		if (d["channel"]:"" == channel)
		    ret = index;
	    });
	return ret;
    }


/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list<string> Summary()
{
    list<string> ret = maplist (integer index, map<string,any> d, devices, {
	// summary text, %1 is channel (number), // %2 and %3 are Yes or No
	return sformat(_("Channel: %1, Format: %2, DIAG: %3"), d["channel"]:"",
		       String::YesNo(d["format"]:false), String::YesNo(d["diag"]:false));
    });
    y2milestone("Summary: %1", ret);
    return ret;
}


/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    return $[ "install":[], "remove":[] ];
}


/**
 * Check if DASD subsystem is available
 * @return boolean True if more than one disk
 */
global boolean IsAvailable()
{
    list<map<string, any> > disks = (list<map<string,any> >) SCR::Read(.probe.disk);
    disks = filter (map<string,any> d, disks, { return tolower(d["device"]:"") == "dasd"; });

    integer count = size (disks);
    y2milestone ("Detected %1 DASD disks", count);

    return count > 0;
}


/**
 * Probe for DASD disks
 */
global void ProbeDisks()
{
    // popup label
    UI::OpenDialog (`Label (_("Reading Configured DASD Disks")));

    list<map<string, any> > disks = (list<map<string, any> >) SCR::Read(.probe.disk);
    disks = filter (map<string, any> d, disks, { return tolower(d["device"]:"") == "dasd"; });

    disks = maplist (map<string,any> d, disks, {
	string channel = d["sysfs_bus_id"]:"";
	d["channel"] = channel;

	boolean active = d["resource", "io", 0, "active"]:false;
	if (active)
	{
	    string device = d["dev_name"]:"";
	    map scr_out = (map)SCR::Execute (.target.bash_output, sformat (
		    "dasdview -x -f '%1' | grep formatted", device));
	    boolean formatted = false;
	    if (scr_out["exit"]:0 == 0)
	    {
		string out = scr_out["stdout"]:"";
		formatted = ! regexpmatch (toupper (out), "NOT[ \t]*FORMATTED");
	    }
	    d["formatted"] = formatted;
	    d["partition_info"] = GetPartitionInfo (device);

	    string diag_file = sformat("/sys/%1/device/use_diag", d["sysfs_id"]:"");
	    if (FileUtils::Exists(diag_file))
	    {
		string use_diag = (string) SCR::Read(.target.string, diag_file);
		d["diag"] = substring(use_diag, 0, 1) == "1";
		diag[channel] = substring(use_diag, 0, 1) == "1";
	    }
	}

	d = filter(string k, any v, d, { return contains([ "channel", "diag",
	    "resource", "formatted", "partition_info", "dev_name", "detail",
	    "device_id", "sub_device_id" ], k); });

	return d;
    });

    integer index = -1;
    devices = listmap (map<string, any> d, disks, {
	index = index + 1;
	return $[ index : d ];
    });

    y2milestone("probed DASD devices %1", devices);

    UI::CloseDialog ();
}


/**
 * Report error occured during device activation
 * @param channel string channel of the device
 * @param ret integer exit code of the operation
 */
void ReportActivationError(string channel, integer ret)
{
    switch (ret)
    {
	case 0:
	    break;

	case 1:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: sysfs not mounted."), channel));
	    break;

	case 2:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Invalid status for <online>."), channel));
	    break;

	case 3:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: No device found for <ccwid>."), channel));
	    break;

	case 4:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Could not change state of the device."), channel));
	    break;

	case 5:
	    // https://bugzilla.novell.com/show_bug.cgi?id=446998#c15
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Device is not a DASD."), channel));
	    break;

	case 6:
	    // https://bugzilla.novell.com/show_bug.cgi?id=446998#c15
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Could not load module."), channel));
	    break;

	case 7:
	    // http://bugzilla.novell.com/show_bug.cgi?id=561876#c8
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Failed to activate DASD."), channel));
	    break;

	case 8:
	    // http://bugzilla.novell.com/show_bug.cgi?id=561876#c8
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: DASD is not formatted."), channel));
	    break;

	default:
	    Report::Error (sformat (
		// error report, %1 is device identification, %2 is integer code
		_("%1: Unknown error %2."), channel, ret));
	    break;
    }
}


/**
 * Activate disk
 * @param channel string Name of the disk to activate
 * @param diag boolean Activate DIAG or not
 */
global void ActivateDisk(string channel, boolean diag)
{
    string command = sformat("/sbin/dasd_configure '%1' %2 %3", channel, 1, diag ? 1 : 0);
    y2milestone("Running command \"%1\"", command);
    integer ret = (integer) SCR::Execute(.target.bash, command);
    y2milestone("Command \"%1\" returned with exit code %2", command, ret);

    if (ret == 8)
    {
      string popup = sformat (_("Device %1 is not formatted. Format device now?
If you want to format multiple devices in parallel,
press 'Cancel' and select 'Perform Action', 'Format' later on.
"), channel);
      if ((Mode::autoinst() && Popup::TimedOKCancel(popup, 10))
        || Popup::ContinueCancel (popup))
      {
	string cmd = sformat("ls '/sys/bus/ccw/devices/%1/block/' | tr -d '\n'", channel);
	map<string, any> disk = (map<string, any>)SCR::Execute(.target.bash_output, cmd);
	if (disk["exit"]:-1 == 0 && size(disk["stdout"]:"")>0){
	    FormatDisks([ sformat("/dev/%1", disk["stdout"]:"") ], 1, true);
	    ActivateDisk(channel, diag);
	} else {
		Popup::Error(sformat("Couldn't find device for %1 channel", channel));
	}
      }
    } else if (ret == 7){
                // when return code is 7, set DASD offline
                // https://bugzilla.novell.com/show_bug.cgi?id=561876#c9
                DeactivateDisk(channel, diag);
               }
       else {
        ReportActivationError(channel, ret);
    }

    disk_configured = true;
}


/**
 * Deactivate disk
 * @param channel string Name of the disk to deactivate
 * @param diag boolean Activate DIAG or not
 */
global void DeactivateDisk(string channel, boolean diag)
{
    string command = sformat("/sbin/dasd_configure '%1' %2 %3", channel, 0, diag ? 1 : 0);
    y2milestone("Running command \"%1\"", command);
    integer ret = (integer) SCR::Execute(.target.bash, command);
    y2milestone("Command \"%1\" returned with exit code %2", command, ret);

    ReportActivationError(channel, ret);

    disk_configured = true;
}


/**
 * Format disks
 * @param disks_list list<string> List of disks to be formated
 * @param par integer Number of disks that can be formated in parallel
 * @param write_vl boolean Write a Volume label
 */
global void FormatDisks(list<string> disks_list, integer par, boolean write_vl)
{
    if (par > size (disks_list))
	par = size (disks_list);

    map<integer,string> disks = $[];
    list<string> disks_cmd = [];
    integer index = -1;
    foreach (string device, disks_list, {
	index = index + 1;
	disks[index] = device;
	disks_cmd = add(disks_cmd, sformat("-f '%1'", device));
    });
    string disks_param = mergestring (disks_cmd, " ");
    string additional_param = "";
    if (! write_vl)
	additional_param = "--no-label";
    string command = sformat("/sbin/dasdfmt -Y -P %2 -b 4096 -y -m 1 %3 %1",
			     disks_param, par, additional_param);

    y2milestone ("Running command %1", command);
    term contents = `VBox (`HSpacing (70));
    index = 0;
    while (index < par)
    {
	// progress bar
	contents = add(contents, `ProgressBar(`id(index), sformat(_("Formatting %1:"),
								  disks[index]:""), 100, 0));
	index = index + 1;
    }
    UI::OpenDialog (contents);
    map<integer,integer> cylinders = $[];
    map<integer,integer> done = $[];
    // start formatting on background
    integer process_id = (integer) SCR::Execute(.process.start_shell, command);
    y2milestone ("Process start returned %1", process_id);
    // get the sizes of all disks
    index = 0;
    while (index < size (disks))
    {
	y2milestone ("Running first formatting cycle");
	sleep (500);

	if (!(boolean) SCR::Read(.process.running, process_id))
	{
	    UI::CloseDialog ();
	    integer iret = (integer) SCR::Read(.process.status, process_id);
	    // error report, %1 is exit code of the command (integer)
	    Report::Error (sformat (_("Disks formatting failed. Exit code: %1."),
		iret));
	    return;
	}

	while (index < size (disks))
	{
	    string line = (string) SCR::Read(.process.read_line, process_id);
	    if (line == nil)
		break;

	    		integer siz = tointeger (line);
			if (siz == 0)
			    siz = 999999999;
			cylinders[index] = siz;
			index = index + 1;
	}
    }
    y2milestone ("Sizes of disks: %1", cylinders);
    y2milestone ("Disks to format: %1", disks);
    list<integer> last_step = [];
    string last_rest = "";
    while ((boolean) SCR::Read(.process.running, process_id))
    {
		    sleep (1000);
		    string buffer = (string) SCR::Read(.process.read, process_id);
		    buffer = last_rest + buffer;
		    list<string> progress = splitstring (buffer, "|");
		    map<integer,integer> this_step = $[];
		    if ((boolean) SCR::Read(.process.running, process_id))
		    {
			integer last = size (progress) - 1;
			last_rest = progress[last]:"";
			progress = remove (progress, last);
		    }
		    foreach (string d, progress, {
			if (d != "")
			{
			    integer i = tointeger (d);
			    this_step[i] = this_step[i]:0 + 1;
			}
		    });
		    foreach (integer k, integer v, this_step, {
			done[k] = done[k]:0 + v;
		    });
		    this_step = filter (integer k, integer v, this_step, {
			return done[k]:0 < cylinders[k]:0;
		    });
		    integer difference = size (last_step) - size (this_step);
		    index = -1;
		    while (difference > 0)
		    {
			index = index + 1;
			if (! haskey (this_step, last_step[index]:0))
			{
			    difference = difference - 1;
			    this_step[last_step[index]:0] = 0;
			}
		    }
		    index = 0;
		    integer siz = size (this_step);
		    foreach (integer k, integer v, this_step, {
			UI::ChangeWidget(`id(index), `Label, sformat(
			    // progress bar, %1 is device name, %2 and %3
			    // integers,
		    // eg. Formatting /dev/dasda: cylinder 123 of 12334 done
			    _("Formatting %1: cylinder %2 of %3 done"),
			    disks[k]:"",
			    done[k]:0,
			    cylinders[k]:0));
			UI::ChangeWidget(`id(index), `Value, 100 * done[k]:0 / cylinders[k]:1);
			UI::ChangeWidget(`id(index), `Enabled, true);
			index = index + 1;
		    });
		    while (index < par)
		    {
			UI::ChangeWidget (`id (index), `Label, "");
			UI::ChangeWidget (`id (index), `Value, 0);
			UI::ChangeWidget (`id (index), `Enabled, false);
			index = index + 1;
		    }
		}
		UI::CloseDialog ();
		integer iret = (integer) SCR::Read(.process.status, process_id);
    if (iret != 0)
    {
	// error report, %1 is exit code of the command (integer)
	Report::Error (sformat (_("Disks formatting failed. Exit code: %1."),
	    iret));
    }
}

/**
 * Get partitioninfo
 * @param disk string Disk to read info from
 * @return GetPartitionInfo string The info
 */
global string GetPartitionInfo (string disk)
{
    map outmap = (map) SCR::Execute (.target.bash_output, sformat("/sbin/fdasd -p '%1'", disk));

    // if not an eckd-disk it's an fba-disk. fba-disks have only one partition
    if (outmap["exit"]:0 != 0)
	return sformat ("%11", disk);

    string out = outmap["stdout"]:"";

    string regexp = "^[ \t]*([^ \t]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([^ \t]+)[ \t]+([^ \t]+([ \t]+[^ \t]+))*[ \t]*$";

    list<string> l = splitstring (out, "\n");
    l = filter (string s, l, {
	return regexpmatch (s, regexp);
    });
    l = maplist (string s, l, {
	list tokens = regexptokenize (s, regexp);
	return sformat ("%1 (%2)", tokens[0]:"", tokens[5]:"");
    });
    return mergestring (l, ", ");
}

}

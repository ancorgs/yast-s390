/**
 * File:	modules/DASDController.ycp
 * Package:	Configuration of controller
 * Summary:	Controller settings, input and output functions
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of controller.
 * Input and output routines.
 */

{

module "DASDController";
textdomain "s390";

import "Progress";
import "Report";
import "Summary";
import "Arch";


global map<integer,map<string,any> > devices = $[];

global map<integer, boolean> selected = $[];

global string filter_min = "0x0000";

global string filter_max = "0xffff";

list<map<string,any> > controllers = nil;



/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return AbortFunction ();
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Is this kind of disk controller available?
 * @return boolean true if it is
 */
global boolean Available () {
    return true;
}

// Settings: Define all variables needed for configuration of controller
// TODO FIXME: Define all the variables necessary to hold
// TODO FIXME: the configuration here (with the appropriate
// TODO FIXME: description)
// TODO FIXME: For example:
//   /**
//    * List of the configured cards.
//    */
//   list cards = [];
//
//   /**
//    * Some additional parameter needed for the configuration.
//    */
//   boolean additional_parameter = true;

/**
 * Read all controller settings
 * @return true on success
 */
global boolean Read() {
    return true;

}

/**
 * Write all controller settings
 * @return true on success
 */
global boolean Write() {
    return true;
}

/**
 * Get all controller settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the controller settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

global define list<map<string,any> > GetControllers () {
    if (controllers == nil)
    {
	controllers = (list<map<string,any> >)SCR::Read (.probe.storage);
	if (Arch::i386)
	    controllers = [$["bus":"None", "class_id":1, "device":"zFCP controller", "device_id":268081, "drivers":[$["active":true, "modprobe":true, "modules":[["zfcp", ""]]]], "model":"IBM zFCP controller", "old_unique_key":"ESHv.6czr7zOIMz1", "resource":$["io":[$["active":true, "length":3, "mode":"rw", "start":64000]]], "sub_class_id":0, "sub_device_id":268082, "unique_key":"rdCR.AbUgA7O1gK4", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":1, "device":"DASD", "model":"IBM DASD", "old_unique_key":"98ht.T2MB916psk1", "sub_class_id":128, "unique_key":"rdCR.T2MB916psk1", "vendor":"IBM"]];
	controllers = filter (map<string,any> c, controllers, {
	    return c["device"]:"" == "DASD";
	});
	y2milestone ("Found %1 dasd controllers", size (controllers));
    }
    return controllers;
}

/**
 * Translate integer number to its hexadecimal representation with leading
 * 0x and exactliy 4 hexadecimal numbers
 * @param i integer integer number
 * @return string hexadecimal number
 */
define string FourDigitHex(integer i) ``{
    string s = tohexstring(i);
    string zeros = "";

    integer l = 6 - size(s);

    while (l > 0) {
	zeros = zeros + "0";
	l = l - 1;
    }

    return substring(s, 0, 2) + zeros + substring(s, 2);
}

global define void ProbeDisks () {

    UI::OpenDialog (`Label (_("Reading configured DASD disks")));

    list<map<string,any> > disks = (list<map<string,any> >)
	SCR::Read (.probe.disk);

    // FIXME remove after testing
    if (! Arch::s390)
	disks = [$["bus":"None", "class_id":262, "cu_model":233, "dev_model":12, "dev_name":"/dev/dasda", "dev_num":$["major":94, "minor":0, "range":4, "type":"b"], "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"N5EP.J4gQoPlOYuE", "prog_if":1, "resource":$["disk_log_geo":[$["cylinders":3338, "heads":15, "sectors":12]], "io":[$["active":true, "length":1, "mode":"rw", "start":336]], "size":[$["unit":"sectors", "x":4806720, "y":512]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"6eUF.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":262, "cu_model":233, "dev_model":10, "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"q1eL.rOENMk3aQ50", "prog_if":1, "resource":$["io":[$["active":false, "length":1, "mode":"rw", "start":400]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"rdCR.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":262, "cu_model":233, "dev_model":10, "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"q1eL.rOENMk3aQ50", "prog_if":1, "resource":$["io":[$["active":false, "length":1, "mode":"rw", "start":401]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"rdCR.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":262, "cu_model":233, "dev_model":10, "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"q1eL.rOENMk3aQ50", "prog_if":1, "resource":$["io":[$["active":false, "length":1, "mode":"rw", "start":413]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"rdCR.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":262, "cu_model":233, "dev_model":10, "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"q1eL.rOENMk3aQ50", "prog_if":1, "resource":$["io":[$["active":false, "length":1, "mode":"rw", "start":414]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"rdCR.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721], $["bus":"None", "class_id":262, "cu_model":233, "dev_model":12, "dev_name":"/dev/dasdb", "dev_names":["/dev/dasdb"], "dev_num":$["major":94, "minor":4, "range":4, "type":"b"], "device":"DASD", "device_id":276880, "lcss":0, "model":"IBM DASD", "old_unique_key":"qGUT.J4gQoPlOYuE", "prog_if":1, "resource":$["disk_log_geo":[$["cylinders":10017, "heads":15, "sectors":0]], "io":[$["active":true, "length":1, "mode":"rw", "start":4242]], "size":[$["unit":"sectors", "x":0, "y":512]]], "sub_class_id":0, "sub_device_id":275344, "unique_key":"ZpkJ.ALFATSt_U8F", "vendor":"IBM", "vendor_id":286721]];

    disks = filter (map<string,any> d, disks, ``(
	issubstring (d["dev_name"]:"", "dasd")
    ));
    disks = maplist (map<string,any> d, disks, ``{
	string channel = FourDigitHex (d["resource", "io", 0, "start"]:0);
	string lcss = FourDigitHex (d["lcss"]:0);
	channel = sformat ("%1.%2.%3",
	    substring (lcss, 4, 1),
	    substring (lcss, 5, 1),
	    substring (channel, 2, 4));
	d["channel"] = channel;
	return d;
    });
    DASDController::devices = listmap (map<string,any> d, disks, ``{
	integer id = (integer)(d["resource", "io", 0, "start"]:0);
	return $[ id : d ];
    });

    UI::CloseDialog ();
}

/* EOF */
}

/**
 * File:	modules/OnPanic.ycp
 * Package:	Configuration of OnPanic
 * Summary:	Configuration of kernel panic reaction
 * Authors:	Tim Hardeck <thardeck@suse.de>
 *
 * Representation of the dumpconf configuration.
 * Input and output routines.
 */

{

module "OnPanic";
textdomain "s390";

import "FileUtils";
import "Progress";
import "Service";
import "String";
import "Integer";

/**
 * Maximal allowed characters for VMCMD?
 */
global const integer VMCMD_MAX_CHARS	= 400;

/**
 * Data was modified?
 */
global boolean modified					= false;

/**
 * Should dumpconf be started?
 */
global boolean start					= false;

/**
 * Panic reaction
 */
global string on_panic					= "";

/**
 * Delay minutes
 */
global integer delay_min		= 5;

/**
 * VMCMD commands
 */
global string vmcmds			= "";

/**
 * Dump Device mkdump line
 */
global string dump_line			= "";

/**
 * Dump Devices list of mkdump (no need to run mkdump more than once)
 */
global list<string> dump_devices	= nil;


/**Get a List of available Dump Devices
 * @return list<string> of disks
 */
define list<string> AvailableDumpDevices () {
	string cmd = "mkdump --list-dump";
	y2milestone ("Running command %1", cmd);
	map output = (map) SCR::Execute(.target.bash_output, cmd);
	y2milestone ("Command return code: %1", (integer)output["exit"]:0);
	y2milestone ("Command output:\n%1\n%2", output["stdout"]:"", output["stderr"]:"");
	list<string> dev_names =  String::NewlineItems (output["stdout"]:"");
	return dev_names;
}

/**Converts a MKDump entry to a device parameters map for dumpconf
 * @param mkdump device line
 * @return map of device parameters
 */
define map ConvertMkdumpToConf (string dev_line) {
	map dev = $[ ];

	list<string> entry = splitstring(dev_line, "\t");
	boolean is_dasd = regexpmatch(entry[0]:nil, "^\/dev\/dasd[a-z]+$");
	boolean is_zfcp = regexpmatch(entry[0]:nil, "^\/dev\/sd[a-z]+$");

	if (is_dasd)
	{
		dev = add(dev, "DUMP_TYPE", "ccw");
		dev = add(dev, "DEVICE", entry[2]:nil);
	}
	if (is_zfcp)
	{
		dev = add(dev, "DUMP_TYPE", "fcp");
		dev = add(dev, "DEVICE", entry[2]:nil);
		dev = add(dev, "WWPN", entry[3]:nil);
		dev = add(dev, "LUN", entry[4]:nil);
		dev = add(dev, "BOOTPROG", "0");
		dev = add(dev, "BR_LBA", "0");
	}

	if (!is_dasd && !is_zfcp )
	{
		y2milestone ("Incompatible mkdump line in ConvertMkdumpToConf(): \"%1\"", dev_line);
	}

	return dev;
}

/**Converts device parameters of dumpconf to an mkdump entry
 * @param dumpconf device map
 * @return string of a mkdump entry
 */
define string ConvertConfToMkdump (map dev) {
	string mkdump = "";

	string type = (string) dev["DUMP_TYPE"]:nil;
	foreach (string entry, dump_devices,{
		list<string> line = splitstring(entry, "\t");
		if ( // check for fitting dasd
		  (type == "ccw" && regexpmatch(line[0]:nil, "^\/dev\/dasd[a-z]+")
			&& line[2]:nil == dev["DEVICE"]:nil)
		  || // check for fitting zfcp
		  (type == "fcp" && regexpmatch(line[0]:nil, "^\/dev\/sd[a-z]+")
			&& line[2]:nil == dev["DEVICE"]:nil
			&& line[3]:nil == dev["WWPN"]:nil
			&& line[4]:nil == dev["LUN"]:nil)
		  )
		{
			mkdump = entry;
			y2milestone ("In /etc/sysconfig/dumpconf configured dump device found: %1", mkdump);
			break;
		}
	});

	if (mkdump == "")
	{
		y2milestone ("Couldn't find the configured dump device.");
	}

	return mkdump;
}


/**
 * Read OnPanic settings from /etc/sysconfig/dumpconf
 * @return true when file exists
 */
global define boolean ReadSysconfig () {
	y2milestone ("Reading Sysconfig entries");
	if (FileUtils::Exists ("/etc/sysconfig/dumpconf"))
	{
		on_panic = (string) SCR::Read (.sysconfig.dumpconf.ON_PANIC);

		delay_min = tointeger ((string) SCR::Read (.sysconfig.dumpconf.DELAY_MINUTES));
		if (delay_min < 0)
			delay_min = 5;

		map dump_device = $[ ];
		foreach (string type, ["DUMP_TYPE", "DEVICE", "WWPN", "LUN", "BOOTPROG", "BR_LBA"],{
			string value = (string) SCR::Read (.sysconfig.dumpconf + type);
			if (value != "")
			{
				dump_device = add(dump_device, type, value);
			}
		});
		dump_line = ConvertConfToMkdump(dump_device);

		string config_entry = "";
		foreach(integer i, Integer::RangeFrom(1, 6), {
			config_entry = (string) SCR::Read (.sysconfig.dumpconf + ("VMCMD_" + tostring(i)));
			if (config_entry != "")
			{
				// prevent leading newline
				if (vmcmds == "")
				{
					vmcmds = config_entry;
				}
				else
				{
					vmcmds = mergestring([vmcmds, config_entry], "\n");
				}
			}
		});

		return true;
	}
	return false;
}

/**
 * Read all OnPanic settings
 * @return true on success
 */
global define boolean Read () {
	/* Dumpconf read dialog caption */
	string caption	= _("Reading Dumpconf Configuration");
	integer steps	= 2;

	Progress::New (caption, " ", steps, [
		/* Progress stage 1/2 */
		_("Checking dump devices"),
		/* Progress stage 2/2 */
		_("Reading settings")
	], [
		/* Progress step 1/2 */
		_("Checking dump devices..."),
		/* Progress step 2/2 */
		_("Reading the settings..."),
		/* Progress finished */
		_("Finished")
	],
	""
	);

	Progress::NextStage();
	dump_devices = AvailableDumpDevices();

	Progress::NextStage();
	ReadSysconfig ();
	start = Service::Enabled ("dumpconf");

	Progress::NextStage();

	return true;
}

/**
 * Write all OnPanic settings
 * @return true on success
 */
global define boolean Write () {
	if (!modified)
	{
		return true;
	}

	/* Dumpconf write dialog caption */
	string caption	= _("Saving Dumpconf Configuration");
	integer steps	= 2;

	Progress::New (caption, " ", steps, [
		/* Progress stage 1/2 */
		_("Write the settings"),
		/* Progress stage 2/2 */
		_("Restart the service")
	], [
		/* Progress step 1/2 */
		_("Writing the settings..."),
		/* Progress step 2/2 */
		_("Restarting service..."),
		/* Progress finished */
		_("Finished")
	],
	""
	);

	Progress::NextStage();
	y2milestone ("Writing Sysconfig entries");
	SCR::Write (.sysconfig.dumpconf.ON_PANIC, on_panic);

	SCR::Write (.sysconfig.dumpconf.DELAY_MINUTES, delay_min);

	map dump_device = ConvertMkdumpToConf(dump_line);
	foreach (string type, ["DUMP_TYPE", "DEVICE", "WWPN", "LUN", "BOOTPROG", "BR_LBA"],{
		SCR::Write (.sysconfig.dumpconf + type, dump_device[type]:"");
	});

	list<string> vmcmd_list = splitstring(vmcmds, "\n");
	foreach(integer i, Integer::RangeFrom(1, 6), {
			SCR::Write (.sysconfig.dumpconf + ("VMCMD_" + tostring(i)), vmcmd_list[i-1]:"");
	});

	SCR::Write (.sysconfig.dumpconf, nil);

	Progress::NextStage ();
	// stopping since dumpconf restart doesn't work correctly
	Service::Stop ("dumpconf");
	if (start)
	{
		Service::Enable ("dumpconf");
		Service::Start ("dumpconf");
	}
	else
	{
		Service::Disable ("dumpconf");
	}

	Progress::NextStage();
	return true;
}

/* EOF */
}

/**
 * File:	modules/Dump.ycp
 * Package:	Creation of s390 dump devices
 * Summary:	Creating dump devices for S/390
 * Authors:	Tim Hardeck <thardeck@suse.de>
 *
 */

{

module "Dump";
textdomain "s390";

import "Report";
import "String";
import "Progress";

/**
 * DASD devices list of mkdump
  */
global define list<string> dasd_disks = [ ];
/**
 * ZFCP devices list of mkdump
  */
global define list<string> zfcp_disks = [ ];

/**
 * Get a List of available Disks of type
 * @return list<string> of disks
 */
define list<string> GetAvailableDisks (string type) {
	list<string> device_list = nil;
	if (type == "dasd" || type == "zfcp")
	{
		string cmd = "mkdump --list-" + type;
		y2milestone ("Running command %1", cmd);
		map output = (map) SCR::Execute(.target.bash_output, cmd);
		y2milestone ("Command return code: %1", (integer)output["exit"]:0);
		y2milestone ("Command output:\n%1\n%2", output["stdout"]:"", output["stderr"]:"");
		device_list = String::NewlineItems (output["stdout"]:"");
	}
	return device_list;

}

global define boolean Read () {
	string caption  = _("Checking Disks");
	integer steps   = 2;

	Progress::New (caption, " ", steps, [
	/* Progress stage 1/2 */
	_("Checking DASD disks"),
	/* Progress stage 2/2 */
	_("Checking ZFCP disks")
	], [
	/* Progress step 1/2 */
	_("Checking DASD disks..."),
	/* Progress step 2/2 */
	_("Checking ZFCP disks..."),
	/* Progress finished */
	_("Finished")
	],
	""
	);

	Progress::NextStage();
	dasd_disks = Dump::GetAvailableDisks ("dasd");

	Progress::NextStage();
    zfcp_disks = Dump::GetAvailableDisks ("zfcp");

	Progress::NextStage();
	return (dasd_disks != nil && zfcp_disks != nil);
}

/**
 * Format a disk as DUMP device
 * @param dev string the disk device node
 * @param force boolean true to append the -f parameter
 * @return boolean true on success
 */
global define boolean FormatDisk (string dev, boolean force) {
	string caption  = _("Creating Dump Device[s]");
	integer steps   = 1;

	Progress::New (caption, " ", steps, [
	/* Progress stage 1/1 */
	_("Creating dump device[s]")
	], [
	/* Progress step 1/1 */
	_("Creating dump device[s]. This process might take some minutes."),
	/* Progress finished */
	_("Finished")
	],
	""
	);

	Progress::NextStage();
	string cmd = force
	? "/sbin/mkdump --force"
	: "/sbin/mkdump";
	cmd = cmd + " " + dev;

	y2milestone ("Running command %1", cmd);
	map output = (map) SCR::Execute (.target.bash_output, cmd);
	integer ret = output["exit"]:0;
	string message = output["stdout"]:"";
	string err_message = output["stderr"]:"";

	y2milestone ("mkdump return value: %1", ret);
	if (message != "")
	{
		y2milestone ("mkdump message: %1", message);
	}
	if (err_message != "")
	{
		y2milestone ("mkdump error message: %1", err_message);
	}

	Progress::NextStage();

	if (ret != 0)
	{
	string err = "";
	if (ret == 11)
			// error description
			err = _("Invalid or unusable disk (fatal).");
		else if (ret == 12)
			// error description
			err = _("Incompatible formatting/partitioning, can be corrected with Force.");
		else if (ret == 13)
			// error description
			err = _("Missing support programs.");
		else if (ret == 14)
			// error description
			err = _("Missing or wrong parameters.");
		else if (ret == 15)
			// error description
			err = _("Access problem.");
		else
		// error description, %1 is error code (integer)
		err = sformat (_("Error code from support program: %1."), ret);
		// error report, %1 is device name, %2 error description
		Report::Error (sformat (_("Cannot create dump device %1:\n%2"), dev, err));
		return false;
	}
	return true;
}

/* EOF */
}

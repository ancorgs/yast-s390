/**
 * File:	modules/ZFCPController.ycp
 * Package:	Configuration of controller
 * Summary:	Controller settings, input and output functions
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of controller.
 * Input and output routines.
 */
{
module "ZFCPController";
textdomain "s390";

import "Mode";
import "Report";
import "Popup";
    import "String";


global map<integer,map<string,any> > devices = $[];

    global string filter_min = "0.0.0000";
    global string filter_max = "0.0.ffff";

global map<string, any> previous_settings = $[];

list<map<string,any> > controllers = nil;

map<string,boolean> activated_controllers = $[];


global void ActivateDisk(string channel, string wwpn, string lun);
global void ProbeDisks();
global boolean GetModified();


boolean disk_configured = false;


/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;


/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = GetModified;


/**
 * Abort function
 * @return blah blah lahjk
 */
global boolean Abort()
{
    if(AbortFunction != nil)
	return AbortFunction ();
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean GetModified()
{
    return modified;
}


global void SetModified(boolean value)
{
    modified = value;
}


/**
 * Is this kind of disk controller available?
 * @return boolean true if it is
 */
global boolean Available()
{
    return true;
}


    global boolean IsValidChannel(string channel)
    {
	string regexp = "^([0-9a-fA-F]{1}).([0-9a-fA-F]{1}).([0-9a-fA-F]{1,4})$";
	return regexpmatch(channel, regexp);
    }

    global string FormatChannel(string channel)
    {
	if (!IsValidChannel(channel))
	    return channel;

	list<string> strs = splitstring(tolower(channel), ".");
	strs[2] = String::PadZeros(strs[2]:"", 4);
	return mergestring(strs, ".");
    }

    global boolean IsValidWWPN(string wwpn)
    {
	string regexp = "^0x([0-9a-fA-F]{1,16})$";
	return regexpmatch(wwpn, regexp);
    }

    global string FormatWWPN(string wwpn)
    {
	if (!IsValidWWPN(wwpn))
	    return wwpn;

	return tohexstring(tointeger(wwpn), 16);
    }

    global boolean IsValidFCPLUN(string fcp_lun)
    {
	string regexp = "^0x([0-9a-fA-F]{1,16})$";
	return regexpmatch(fcp_lun, regexp);
    }

    global string FormatFCPLUN(string fcp_lun)
    {
	if (!IsValidFCPLUN(fcp_lun))
	    return fcp_lun;

	return tohexstring(tointeger(fcp_lun), 16);
    }


    global string GetNextLUN(string fcp_lun)
    {
	if (fcp_lun == nil || fcp_lun == "")
	    fcp_lun = "0";

	integer old_lun = tointeger(fcp_lun);
	integer new_lun = old_lun;

	foreach (integer k, map<string, any> v, devices, {
	    if (old_lun == tointeger(v["detail", "fcp_lun"]:""))
	    {
		if (v["vendor"]:"" == "IBM" && v["device"]:"" == "25f03")
		    new_lun = old_lun + 0x100000000;
		else
		    new_lun = old_lun + 1;
	    }
	});

	return tohexstring(new_lun, 16);
    }


/**
 * Read all controller settings
 * @return true on success
 */
global boolean Read()
{
    ProbeDisks();

    disk_configured = false;
    return true;
}


/**
 * Write all controller settings
 * @return true on success
 */
global boolean Write()
{
    if (!Mode::normal())
    {
	foreach (integer index, map<string, any> device, devices, {
		string channel = device["controller_id"]:"";
		string wwpn = device["wwpn"]:"";
		string lun = device["fcp_lun"]:"";
		ActivateDisk(channel, wwpn, lun);
	});
    }

    if (!Mode::installation())
    {
	if (disk_configured)
	{
	    // popup label
	    UI::OpenDialog(`Label(_("Running mkinitrd and zipl.")));

	    string command = "/sbin/mkinitrd && /sbin/zipl";
	    y2milestone ("Running command %1", command);
	    any ret = SCR::Execute(.target.bash, command);
	    y2milestone("Exit code: %1", ret);

	    UI::CloseDialog();
	}
    }

    return true;
}


/**
 * Get all controller settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import(map settings)
{
	integer index = -1;
	devices = listmap (map d, settings["devices"]:[], {
	    index = index + 1;
	    map<string, any> m = $[
		"detail" : $[
		    "controller_id" : FormatChannel(d["controller_id"]:""),
		    "wwpn" : FormatWWPN(d["wwpn"]:""),
		    "fcp_lun" : FormatFCPLUN(d["fcp_lun"]:""),
		],
	    ];
	    return $[ index : m ];
	});

    return true;
}


/**
 * Dump the controller settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export()
{
    list<map<string, any> > l = maplist (integer k, map<string, any> v, devices, {
	return $[
	    "controller_id" : v["detail", "controller_id"]:"",
	    "wwpn" : v["detail", "wwpn"]:"",
	    "fcp_lun" : v["detail", "fcp_lun"]:"",
	]; });

    return $[ "devices" : l, ];
}


    global map<integer, map<string, any> >
    GetDevices()
    {
	return devices;
    }


    global map<integer, map<string, any> >
    GetFilteredDevices()
    {
	list<string> min_strs = splitstring(filter_min, ".");
	integer min_css = tointeger("0x" + min_strs[0]:"");
	integer min_lcss = tointeger("0x" + min_strs[1]:"");
	integer min_chan = tointeger("0x" + min_strs[2]:"");

	list<string> max_strs = splitstring(filter_max, ".");
	integer max_css = tointeger("0x" + max_strs[0]:"");
	integer max_lcss = tointeger("0x" + max_strs[1]:"");
	integer max_chan = tointeger("0x" + max_strs[2]:"");

	map<integer, map<string, any> > ret = GetDevices();

	if (min_chan > 0 || min_lcss > 0 || min_css > 0 ||
	    max_chan < 0xffff || max_lcss < 0xf || max_css < 0xf)
	{
	    y2milestone("filter devices: %1.%2.%3 to %4.%5.%6", min_css, min_lcss, min_chan,
			max_css, max_lcss, max_chan);

	    ret = filter(integer k, map<string, any> d, ret, {
		list<string> tmp_strs = splitstring(d["channel"]:"", ".");
		integer tmp_css = tointeger("0x" + tmp_strs[0]:"");
		integer tmp_lcss = tointeger("0x" + tmp_strs[1]:"");
		integer tmp_chan = tointeger("0x" + tmp_strs[2]:"");

		return tmp_css >= min_css && tmp_lcss >= min_lcss && tmp_chan >= min_chan &&
		    tmp_css <= max_css && tmp_lcss <= max_lcss && tmp_chan <= max_chan;
	    });
	}

	return ret;
    }


    global void
    AddDevice(map<string, any> d)
    {
	integer index = 0;
	while (haskey(devices, index))
	    index = index + 1;
	devices[index] = d;
    }


    global void
    RemoveDevice(integer index)
    {
	devices = remove(devices, index);
    }


    global integer
    GetDeviceIndex(string channel)
    {
	integer ret = nil;
	foreach(integer index , map<string, any> d, devices, {
		if (d["channel"]:"" == channel)
		    ret = index;
	    });
	return ret;
    }


/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list<string> Summary()
{
    list<string> ret = maplist (integer index, map<string,any> d, devices, {
	// summary text, %1 is channel, %1 is WWPN, %3 is LUN
	// (all of them are numbers)
	return sformat(_("Channel: %1, WWPN: %2, ZFCP LUN: %3"),
		       d["detail", "controller_id"]:"", d["detail", "wwpn"]:"",
		       d["detail", "fcp_lun"]:"");
    });
    y2milestone("Summary: %1", ret);
    return ret;
}


/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    return $[ "install":[], "remove":[] ];
}


/**
 * Get available zfcp controllers
 * @return list<map<string,any> > of availabel Controllers
 */
global list<map<string, any> > GetControllers()
{
    if (controllers == nil)
    {
	controllers = (list<map<string,any> >)SCR::Read (.probe.storage);
	controllers = filter (map<string,any> c, controllers, {
	    return c["device"]:"" == "zFCP controller";
	});

	y2milestone ("probed ZFCP controllers %1", controllers);
    }
    return controllers;
}


/**
 * Check if ZFCP subsystem is available
 * @return boolean whether the ZFCP-System is availble at all
 */
global boolean IsAvailable()
{
    return !isempty(GetControllers());
}


/**
 * Get available disks
 */
global void ProbeDisks()
{
    // popup label
    UI::OpenDialog(`Label(_("Reading Configured ZFCP Devices")));

    list<map<string, any> > disks = (list<map<string, any> >) SCR::Read(.probe.disk);
    disks = filter(map<string, any> d, disks, { return d["bus"]:"" == "SCSI"; });

    list<map<string, any> > tapes = (list<map<string, any> >) SCR::Read(.probe.tape);
    tapes = filter(map<string, any> d, tapes, { return d["bus"]:"" == "SCSI"; });

    list<map<string, any> > disks_tapes = (list<map<string, any> >) merge(disks, tapes);

    integer index = -1;
    devices = listmap (map<string, any> d, disks_tapes, {
	index = index + 1;
	return $[ index : d ];
    });

    y2milestone("probed ZFCP devices %1", devices);

    UI::CloseDialog();
}


/**
 * Report error occured during device activation
 * @param channel string channel of the device
 * @param ret integer exit code of the operation
 */
void ReportActivationError(string channel, integer ret)
{
    switch (ret)
    {
	case 0:
	    break;

	case 1:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: sysfs not mounted."), channel));
	    break;

	case 2:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Invalid status for <online>."), channel));
	    break;

	case 3:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: No device found for <ccwid>."), channel));
	    break;

	case 4:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: WWPN invalid."), channel));
	    break;

	case 5:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Could not activate WWPN for adapter %1."), channel));
	    break;

	case 6:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Could not activate ZFCP device."), channel));
	    break;

	case 7:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: SCSI disk could not be deactivated."), channel));
	    break;

	case 8:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: ZFCP LUN could not be unregistered."), channel));
	    break;

	case 9:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: ZFCP WWPN could not be unregistered."), channel));
	    break;

	default:
	    Report::Error (sformat (
		// error report, %1 is device identification, %2 is integer code
		_("%1: Unknown error %2."), channel, ret));
	    break;
    }
}


/**
 * Report error occured during device activation
 * @param channel string channel of the device
 * @param ret integer exit code of the operation
 */
void ReportControllerActivationError(string channel, integer ret)
{
    switch (ret)
    {
	case 0:
	    break;

	case 1:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: sysfs not mounted."), channel));
	    break;

	case 2:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Invalid status for <online>."), channel));
	    break;

	case 3:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Device <ccwid> does not exist."), channel));
	    break;

	case 4:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Module zfcp could not be loaded."), channel));
	    break;

	case 5:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Adapter status could not be changed."), channel));
	    break;

	case 6:
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: WWPN ports still active."), channel));
	    break;

	default:
	    Report::Error (sformat (
		// error report, %1 is device identification, %2 is integer code
		_("%1: Unknown error %2."), channel, ret));
	    break;
    }
}


/**
 * Activate a disk
 * @param channel string channel
 * @param wwpn string wwpn (hexa number)
 * @param lun string lun   (hexa number)
 */
global void ActivateDisk(string channel, string wwpn, string lun)
{
    if (! activated_controllers[channel]:false)
    {
	string command = sformat("/sbin/zfcp_host_configure '%1' %2", channel, 1);
	y2milestone("Running command \"%1\"", command);
	integer ret = (integer) SCR::Execute(.target.bash, command);
	y2milestone("Command \"%1\" returned with exit code %2", command, ret);

	if (ret != 0)
	{
	    ReportControllerActivationError(channel, ret);
	}
	else
	{
	    activated_controllers[channel] = true;
	}
    }

    string command = sformat("/sbin/zfcp_disk_configure '%1' '%2' '%3' %4", channel,
			     wwpn, lun, 1);
    y2milestone("Running command \"%1\"", command);
    integer ret = (integer) SCR::Execute(.target.bash, command);
    y2milestone("Command \"%1\" returned with exit code %2", command, ret);

    ReportActivationError(channel, ret);

    disk_configured = true;
}


/**
 * Deactivate a disk
 * @param channel string channel
 * @param wwpn string wwpn (hexa number)
 * @param lun string lun   (hexa number)
 */
global void DeactivateDisk(string channel, string wwpn, string lun)
{
    string command = sformat("/sbin/zfcp_disk_configure '%1' '%2' '%3' %4", channel,
			     wwpn, lun, 0);
    y2milestone("Running command \"%1\"", command);
    integer ret = (integer) SCR::Execute(.target.bash, command);
    y2milestone("Command \"%1\" returned with exit code %2", command, ret);

    ReportActivationError(channel, ret);

    disk_configured = true;
}


 list<string> runCommand(string cmd){
  list<string> ret = [];
  map<string, any> cmd_output = (map<string, any>)SCR::Execute(.target.bash_output, cmd);
  if (cmd_output["exit"]:-1==0){
   ret = splitstring(cmd_output["stdout"]:"", "\n");
   ret = filter(string row, ret, {return (size(row)>0);});
  } else {
    Popup::Error(cmd_output["stderr"]:"");
   }
  y2milestone("command %1, output %2", cmd, cmd_output);
  return ret;
 }

 global list<string> GetWWPNs(string busid){
  return runCommand(sformat("zfcp_san_disc -b '%1' -W", busid));
 }

 global list<string> GetLUNs(string busid, string wwpn){
  return runCommand(sformat("zfcp_san_disc -b '%1' -p '%2' -L", busid, wwpn));
 }

}

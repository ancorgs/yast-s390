/**
 * File:	include/controller/dialogs.ycp
 * Package:	Configuration of controller
 * Summary:	Dialogs definitions
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 */

{

textdomain "s390";

import "Arch";
import "DASDController";
import "Label";
import "Popup";
import "Progress";
import "Report";
import "Sequencer";
import "Wizard";

include "s390/dasd/helps.ycp";

/**
 * List DASD devices that are currently being selected
 * @return list of IDs of sellected DASD devices
 */
define list<integer> ListSelectedDASD () ``{
    map<integer, boolean> sel_list = (map<integer, boolean>)filter (
	integer k, boolean v, DASDController::selected,
    ``(
	v == true
    ));
    list<integer> to_activate = maplist (integer k, boolean v, sel_list, ``(k));
    y2milestone ("Selected list: %1", to_activate);
    return to_activate;
}


// --------------------------------------------------------------------------


/**
 * Report error occured during device activation
 * @param id integer chanel id of the device
 * @param ret integer exit code of the operation
 */
define void ReportActivationError (any id, integer ret) {
    if (ret != 0)
    {
	if (ret == 1)
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: sysfs not mounted."), id));
	else if (ret == 2)
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Invalid status for <online>"), id));
	else if (ret == 3)
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: No device found for <ccwid>"), id));
	else if (ret == 4)
	    Report::Error (sformat (
		// error report, %1 is device identification
		_("%1: Could not change state of the device"), id));
	else
	    Report::Error (sformat (
		// error report, %1 is device identification, %2 is integer code
		_("%1: Unknown error %2"), id, ret));
    }
}

// now real dialogs

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(DASD_HELPS["read"]:"");
    // Controller::AbortFunction = PollAbort;
    boolean ret = DASDController::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(DASD_HELPS["write"]:"");
    // Controller::AbortFunction = PollAbort;
    boolean ret = DASDController::Write();
    return ret ? `next : `abort;
}

/**
 * Get the list of items for the table of DASD devices
 * @param min_chan integer minimal channel number
 * @param max_chan integer maximal channel number
 * @return a list of terms for the table
 */
define list<term> GetDASDDiskItems(integer min_chan, integer max_chan) ``{
    integer id = 0;

    list<term> items = [];

    map<integer,map<string,any> > devices = DASDController::devices;

    if (min_chan >= 0)
    {
	devices = (map<integer,map<string,any> >)filter (
	    integer k, map<string,any> d, devices,
        ``{
	    return (k >= min_chan && k <= max_chan);
	});
    }
    items = (list<term>) maplist (integer k, map<string,any> d, devices, ``{
	boolean active = (boolean)(d["resource", "io", 0, "active"]:false);
	integer channel = (integer)(d["resource", "io", 0, "start"]:0);
	string str_channel = (string)(d["channel"]:"");
	string access = toupper ((string)(d["resource", "io", 0, "mode"]:"RO"));
	boolean diag = d["diag"]:false; // TODO
	string formatted = (boolean)(d["formatted"]:false) // TODO
	    // table cell
	    ? _("Yes")
	    // table cell
	    : _("No");
	string partition_info = d["partitions"]:""; // TODO
	string device = d["dev_name"]:"";
	string type = toupper (sformat ("%1/%2, %3/%4",
	    substring (
		DASDController::FourDigitHex (
		    d["device_id"]:0 & tointeger ("0xffff")
		),
		2),
	    substring (
		DASDController::FourDigitHex (d["detail", "cu_model"]:0),
		4),
	    substring (
		DASDController::FourDigitHex (
		    d["sub_device_id"]:0 & tointeger ("0xffff")
		),
		2),
	    substring (
		DASDController::FourDigitHex (d["detail", "dev_model"]:0),
		4)
	));

	boolean activate = d["activate"]:false;
	if (!active) {
	    type = "--";
	    access = "--";
	    formatted = "--";
	    partition_info = "--";
	    device = "--";
	}
	string selected = DASDController::selected[channel]:false
	    ? UI::Glyph (`CheckMark)
	    : "-";

	term t = `item (`id (channel), selected, str_channel, device,
	    type ,access);
	if (Arch::s390_32)
	    t = add (t, diag);
	t = add (t, formatted);
	t = add (t, partition_info);
	return t;
    });
    return items;
}

/**
 * Draw the DASD dialog
 */
define void DisplayDASDDialog() {
    /* Minimal text for the help */
    string help = _("TODO Temporary dialog for DSDA disks configuration.");

    /* Dialog caption */
    string caption = _("DASD Disks Management");

    term header = `header(
	// table header
	_("Sel."),
	// table header
	`Right(_("Channel")),
	// table header
	_("Device"),
	// table header
	_("Type"),
	// table header
	_("Access type"));
    if (Arch::s390_32)
	// table header
	header = add (header, _("Use DIAG"));
    // table header
    header = add (header, _("Formatted"));
    // table header
    header = add (header, _("Partition information"));

    list actions = [
	// menuy button id
	`item (`id (`activate), _("&Activate")),
	// menuy button id
	`item (`id(`deactivate), _("&Deactivate")),
	// menuy button id
	`item (`id(`format), _("&Format")),
    ];

    /* Dialog content */
    term content = `VBox(
	`HBox(
	    // text entry
	    `TextEntry(`id(`min_chan), _("Mi&nimal channel"), "0x0000"),
	    // text entry
	    `TextEntry(`id(`max_chan), _("Ma&ximal channel"), "0xffff"),
	    `VBox (
		`Label (""),
		// push button
		`PushButton (`id (`filter), _("&Filter"))
	    )
	),
	`Table(`id(`table), `opt (`notify), header, []),
	`HBox (
	    // pudh button
	    `PushButton (`id (`select), _("&Select/Deselect")),
	    `HStretch (),
	    // menu button
	    `MenuButton (`id (`operation), _("Perform &Action"), actions)
	)
    );

    /* Apply the settings */
    Wizard::SetContents(caption, content, help, true, true);
    Wizard::HideBackButton();
    Wizard::SetAbortButton(`abort, Label::CancelButton() );
}


/**
 * Redraw the contents of the widgets in the DASD Dialog
 */
define void ReloadDASDDialog () ``{
    DASDController::filter_min = (string)
	UI::QueryWidget(`min_chan, `Value);
    DASDController::filter_max = (string)
	UI::QueryWidget(`max_chan, `Value);


    DASDController::ProbeDisks ();

    list<term> items = GetDASDDiskItems (
	tointeger(DASDController::filter_min),
	tointeger(DASDController::filter_max));

    UI::ChangeWidget(`id(`table), `Items, items);
    UI::SetFocus (`table);
}

/**
 * Run the dialog for DASD disks configuration
 * @return symbol for wizard sequencer
 */
define symbol DASDDialog() {
    DisplayDASDDialog ();
    ReloadDASDDialog ();
    any ret = nil;

    while (ret == nil)
    {
	ret = UI::UserInput();

	integer selected = (integer)
	    UI::QueryWidget (`id (`table), `CurrentItem);

	if (ret == `filter) {
	    ReloadDASDDialog ();
	    ret = nil;
	    continue;
	}
	else if (ret == `table || ret == `select)
	{
	    DASDController::selected[selected]
		= ! DASDController::selected[selected]:false;
	    UI::ChangeWidget (`id (`table), `Item (selected, 0),
		DASDController::selected[selected]:false
		    ? UI::Glyph (`CheckMark)
		    : "-");
	    ret = nil;
	    UI::SetFocus (`table);
	    continue;
	}
	else if (ret == `activate)
	{
	    list<integer>to_activate = ListSelectedDASD ();
	    if (0 == size (to_activate))
	    {
		Popup::Message (_("No disk selected."));
		ret = nil;
		continue;
	    }
	    foreach (integer id, to_activate, ``{
		string command = sformat (
		    "/sbin/dasd_configure %1 %2 %3",
		    DASDController::devices[id,"channel"]:"",
		    1,
		    0
		);
		boolean run = true;
		if (! Popup::YesNo (sformat ("Execute command %1", command)))
		{
		    run = false;
		}
		if (run)
		{
		    integer ret = (integer)SCR::Execute (.target.bash, command);
		    ReportActivationError (id, ret);
		}
	    });

	    ReloadDASDDialog ();

//	    UI::ChangeWidget(`id(`table), `CurrentItem, ids_to_activate[0]:nil);
	    ret = nil;

	}
	else if (ret == `deactivate)
	{
	    list<integer>to_activate = ListSelectedDASD ();
	    if (0 == size (to_activate))
	    {
		// error popup message
		Popup::Message (_("No disk selected."));
		ret = nil;
		continue;
	    }
	    foreach (integer id, to_activate, ``{
		string command = sformat (
		    "/sbin/dasd_configure %1 %2 %3",
		    DASDController::devices[id,"channel"]:"",
		    0,
		    0
		);
		boolean run = true;
		if (! Popup::YesNo (sformat ("Execute command %1", command)))
		{
		    run = false;
		}
		if (run)
		{
		    integer ret = (integer)SCR::Execute (.target.bash, command);
		    ReportActivationError (id, ret);
		}
	    });

	    ReloadDASDDialog ();

//	    UI::ChangeWidget(`id(`table), `CurrentItem, ids_to_activate[0]:nil);
	    ret = nil;
	}
	else if (ret == `format)
	{
	    list<integer>to_activate = ListSelectedDASD ();
	    if (0 == size (to_activate))
	    {
		Popup::Message (_("No disk selected."));
		ret = nil;
		continue;
	    }
	    integer par = 8;
	    map<integer,string> disks = $[];
	    list<string> disks_cmd = [];
	    integer index = -1;
	    foreach (integer id, to_activate, ``{
		string device = DASDController::devices[id, "dev_name"]:"";
		index = index + 1;
		disks[index] = device;
		disks_cmd = add (disks_cmd, sformat ("-f %1", device));
	    });
	    if (par > size (disks_cmd))
		par = size (disks_cmd);
	    // check if disks are R/W and active
	    string problem = "";
	    foreach (integer id, to_activate, {
		boolean active = (boolean)
		    (DASDController::devices[id, "resource", "io", 0, "active"]:false);
		string access = toupper (
		    (string)(DASDController::devices[id, "resource", "io", 0, "mode"]:"RO"));
		if (! active)
		{
		    // error report, %1 is device identification
		    problem = sformat (_("Disk %1 is not active"),
			DASDController::devices[id, "channel"]:"");
		}
		else if (tolower (access) != "rw")
		{
		    problem = sformat (
			// error report, %1 is device identification
			_("Disk %1 is not accessible for writing"),
			DASDController::devices[id, "channel"]:"");
		}
	    });
	    if (problem != "")
	    {
		Popup::Message (problem);
		ret = nil;
		continue;
	    }
	    boolean cancel = false;
	    UI::OpenDialog (`VBox (
		`IntField (`id (`par),
		    // integer field (count of disks formatted at parallely)
		    _("Parallell Formatted Disks"), 1, par, par),
		`HBox (
		    `HStretch (),
		    `PushButton (`id (`ok), Label::OKButton ()),
		    `PushButton (`id (`cancel), Label::CancelButton ()),
		    `HStretch ()
		)
	    ));
	    ret = UI::UserInput ();
	    par = (integer)UI::QueryWidget (`id (`par), `Value);
	    UI::CloseDialog ();
	    if (ret == `cancel)
	    {
		UI::SetFocus (`table);
		ret = nil;
		continue;
	    }
	    string disks_param = mergestring (disks_cmd, " ");
	    string command = sformat (
		"/sbin/dasdfmt -Y -P %2 -b 4096 -y -m 1 %1", disks_param, par);
	    boolean run = true;
	    if (! Popup::YesNo (sformat ("Execute command %1", command)))
	    {
		run = false;
	    }
	    if (run)
	    {
		term contents = `VBox (`HSpacing (70));
		index = 0;
		while (index < par)
		{
		    contents = add (contents, `ProgressBar (`id (index),
			" ", 100, 0));
		    index = index + 1;
		}
		UI::OpenDialog (contents);
		map<integer,integer> cylinders = $[];
		map<integer,integer> done = $[];
		// start formatting on background
		SCR::Execute (.background.run_output, command);
		// get the sizes of all disks
		index = 0;
		while (index < size (disks))
		{
		    sleep (500);
		    list new_lines = (list)
			SCR::Read (.background.newout);
		    foreach (any line, new_lines, {
			integer siz = tointeger (line);
			if (siz == 0)
			    siz = 999999999;
			cylinders[index] = siz;
			index = index + 1;
		    });
		}
		y2milestone ("Sizes of disks: %1", cylinders);
		list<integer> last_step = [];
		while ((boolean)SCR::Read (.background.isrunning))
		{
		    sleep (1000);
		    string buffer = (string)
			SCR::Read (.background.buffer_out);
		    list<string> progress = splitstring (buffer, "|");
		    map<integer,integer> this_step = $[];
		    foreach (string d, progress, {
			if (d != "")
			{
			    integer i = tointeger (d);
			    this_step[i] = this_step[i]:0 + 1;
			}
		    });
		    foreach (integer k, integer v, this_step, {
			done[k] = done[k]:0 + v;
		    });
		    this_step = filter (integer k, integer v, this_step, {
			return done[k]:0 < cylinders[k]:0;
		    });
		    integer difference = size (last_step) - size (this_step);
		    index = -1;
		    while (difference > 0)
		    {
			index = index + 1;
			if (! haskey (this_step, last_step[index]:0))
			{
			    difference = difference - 1;
			    this_step[last_step[index]:0] = 0;
			}
		    }
		    index = 0;
		    integer siz = size (this_step);
		    foreach (integer k, integer v, this_step, {
			UI::ChangeWidget (`id (index), `Label, sformat (
			    // progress bar, %1 is device name, %2 and %3
			    // integers,
		    // eg. Formatting /dev/dasda: cylinder 123 of 12334 done
			    _("Formatting %1: cylinder %2 of %3 done"),
			    disks[k]:"",
			    done[k]:0,
			    cylinders[k]:0));
			UI::ChangeWidget (`id (index), `Value,
			    100 * done[k]:0 / cylinders[k]:1);
			UI::ChangeWidget (`id (index), `Enabled, true);
			index = index + 1;
		    });
		    while (index < par)
		    {
			UI::ChangeWidget (`id (index), `Label, "");
			UI::ChangeWidget (`id (index), `Value, 0);
			UI::ChangeWidget (`id (index), `Enabled, false);
			index = index + 1;
		    }
		}
		UI::CloseDialog ();
		integer ret = (integer)SCR::Read (.background.status);
		if (ret != 0)
		{
		    // error report, %1 is exit code of the command (integer)
		    Report::Error (sformat (_("Disks formatting failed. Exit code: %1"),
			ret));
		}
	    }
	    ReloadDASDDialog ();
	    UI::SetFocus (`table);
	    ret = nil;

	}

    }
    return (symbol)ret;
}

// EOF
}

